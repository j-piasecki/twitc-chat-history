import pg from 'pg';
import fs from 'fs';

const config = JSON.parse(fs.readFileSync("db_config.json", "utf-8"));
const pool = new pg.Pool(config);

export async function initDB() {
    await pool.query(`
        CREATE TABLE IF NOT EXISTS channel_names(
            id INTEGER PRIMARY KEY,
            name VARCHAR(50) NOT NULL UNIQUE
        );
    `);

    await pool.query(`
        CREATE TABLE IF NOT EXISTS user_names(
            id INTEGER PRIMARY KEY,
            name VARCHAR(50) NOT NULL UNIQUE
        );
    `);

    await pool.query(`
        CREATE TABLE IF NOT EXISTS user_channels(
            user_id INTEGER,
            channel_id INTEGER,
            count INTEGER,

            CONSTRAINT pk_user_channels
                PRIMARY KEY(user_id, channel_id),

            CONSTRAINT fk_user_names
                FOREIGN KEY(user_id) REFERENCES user_names(id)
                ON DELETE CASCADE,

            CONSTRAINT fk_channel_names
                FOREIGN KEY(channel_id) REFERENCES channel_names(id)
                ON DELETE CASCADE
        );
    `);

    await pool.query(`
        CREATE TABLE IF NOT EXISTS messages(
            id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            message VARCHAR(500) NOT NULL,
            timestamp BIGINT NOT NULL,
            channel_id INTEGER NOT NULL,
            channel_name VARCHAR(50) NOT NULL,
            user_id INTEGER NOT NULL,
            user_name VARCHAR(50) NOT NULL,

            CONSTRAINT fk_channel
                FOREIGN KEY(channel_id) REFERENCES channel_names(id)
                ON DELETE CASCADE,

            CONSTRAINT fk_user
                FOREIGN KEY(user_id) REFERENCES user_names(id)
                ON DELETE CASCADE
        );
    `);

    await pool.query(`
        CREATE INDEX IF NOT EXISTS channel_timestamp_index ON messages(
            channel_id,
            timestamp DESC
        );
    `);

    await pool.query(`
        CREATE INDEX IF NOT EXISTS channel_user_timestamp_index ON messages(
            channel_id,
            user_id,
            timestamp DESC
        );
    `);

    await pool.query(`
        CREATE INDEX IF NOT EXISTS user_timestamp_index ON messages(
            user_id,
            timestamp DESC
        );
    `);


    await pool.query(`
        CREATE INDEX IF NOT EXISTS channel_names_index ON channel_names USING hash(
            name
        );
    `);

    await pool.query(`
        CREATE INDEX IF NOT EXISTS user_names_index ON user_names USING hash(
            name
        );
    `);

    await pool.query(`
        CREATE OR REPLACE FUNCTION save_message(
            v_msg VARCHAR(500),
            v_timestamp BIGINT,
            v_channel_id INT,
            v_channel_name VARCHAR(50),
            v_user_id INT,
            v_user_name VARCHAR(50)
        )
        RETURNS void
        LANGUAGE plpgsql
        AS $$
        BEGIN
            INSERT INTO channel_names (id, name)
                VALUES (v_channel_id, v_channel_name)
                ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
            INSERT INTO user_names (id, name)
                VALUES (v_user_id, v_user_name)
                ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
            INSERT INTO user_channels (user_id, channel_id, count)
                VALUES (v_user_id, v_channel_id, 1)
                ON CONFLICT (user_id, channel_id) DO UPDATE SET count=user_channels.count + 1;
            INSERT INTO messages (message, timestamp, channel_id, channel_name, user_id, user_name)
                VALUES (v_msg, v_timestamp, v_channel_id, v_channel_name, v_user_id, v_user_name);
        END; $$;
    `);
}

export async function saveMessage(message, channelId, channelName, userId, userName) {
    pool.query(`
        SELECT save_message($1, $2, $3, $4, $5, $6);
    `, [message, Date.now(), channelId, channelName, userId, userName]);
}

export async function getChannelId(channelName) {
    return await pool.query(`SELECT id, name FROM channel_names WHERE name=$1`, [channelName]);
}

export async function getUserId(userName) {
    return await pool.query(`SELECT id, name FROM user_names WHERE name=$1`, [userName]);
}

export async function getUserName(id) {
    return await pool.query(`SELECT id, name FROM user_names WHERE id=$1`, [id]);
}

export async function getMessagesInChannel(channel, amount, lastMessage) {
    const channelIdCheck = (typeof channel === 'number') ?
        `$1` :
        `(SELECT id FROM channel_names WHERE name=$1)`;

    return await pool.query(`
        SELECT * from messages WHERE channel_id=${channelIdCheck} AND id<$2 ORDER BY timestamp DESC LIMIT $3
    `, [channel, lastMessage, amount]);
}

export async function getMessagesInChannelForUser(channel, user, amount, lastMessage) {
    const channelIdCheck = (typeof channel === 'number') ?
        `$1` :
        `(SELECT id FROM channel_names WHERE name=$1)`;

    const userIdCheck = (typeof user === 'number') ?
        `$2` :
        `(SELECT id FROM user_names WHERE name=$2)`;

    return await pool.query(`
        SELECT * from messages WHERE channel_id=${channelIdCheck} AND user_id=${userIdCheck} AND id<$3 ORDER BY timestamp DESC LIMIT $4
    `, [channel, user, lastMessage, amount]);
}

export async function getUserChannels(user) {
    const userIdCheck = (typeof user === 'number') ?
        `$1` :
        `(SELECT id FROM user_names WHERE name=$1)`;

    return await pool.query(`
        SELECT channel_id AS id, channel_names.name, count AS messages
            FROM user_channels INNER JOIN channel_names ON user_channels.channel_id = channel_names.id
            WHERE user_id=${userIdCheck};
    `, [user]);
}